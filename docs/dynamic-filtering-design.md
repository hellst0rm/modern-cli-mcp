# Dynamic Tool Filtering Design

## Current Architecture (rmcp macros)

```rust
#[tool_router]
impl ModernCliTools {
    #[tool(name = "eza", description = "...")]
    async fn eza(&self, params: Parameters<EzaRequest>) -> Result<CallToolResult, ErrorData> {
        // implementation
    }
}

#[tool_handler]
impl ServerHandler for ModernCliTools {
    fn get_info(&self) -> ServerInfo { ... }
    // list_tools() and call_tool() generated by macros
}
```

**Problem:** `list_tools()` is generated at compile time, returns all tools.

## Option A: Manual ServerHandler Implementation

Replace macro-generated handlers with manual implementation that respects visibility.

### Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    ModernCliTools                               │
├─────────────────────────────────────────────────────────────────┤
│  tool_registry: HashMap<String, ToolDefinition>                 │
│  tool_handlers: HashMap<String, BoxedToolHandler>               │
│  visible_tools: RwLock<HashSet<String>>                         │
│  profile: Option<AgentProfile>                                  │
│  expanded_groups: RwLock<HashSet<ToolGroup>>                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│              impl ServerHandler (manual)                        │
├─────────────────────────────────────────────────────────────────┤
│  list_tools() -> only tools in visible_tools                    │
│  call_tool(name) -> lookup in tool_handlers, execute            │
│  get_info() -> profile-aware instructions                       │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation Sketch

```rust
use std::collections::{HashMap, HashSet};
use std::sync::RwLock;
use rmcp::model::{Tool, CallToolResult};

pub struct ToolDefinition {
    pub name: String,
    pub description: String,
    pub input_schema: serde_json::Value,
    pub group: ToolGroup,
}

type ToolHandler = Box<dyn Fn(serde_json::Value) -> BoxFuture<'static, Result<CallToolResult, ErrorData>> + Send + Sync>;

pub struct ModernCliTools {
    executor: CommandExecutor,
    state: Arc<StateManager>,
    profile: Option<AgentProfile>,

    // Tool registry
    tool_definitions: HashMap<String, ToolDefinition>,
    tool_handlers: HashMap<String, ToolHandler>,

    // Visibility state
    expanded_groups: RwLock<HashSet<ToolGroup>>,
}

impl ModernCliTools {
    pub fn new(profile: Option<AgentProfile>) -> Self {
        let mut tools = Self {
            executor: CommandExecutor::new(),
            state: Arc::new(StateManager::new().unwrap()),
            profile,
            tool_definitions: HashMap::new(),
            tool_handlers: HashMap::new(),
            expanded_groups: RwLock::new(HashSet::new()),
        };

        // Register all tools
        tools.register_filesystem_tools();
        tools.register_git_tools();
        tools.register_github_tools();
        // ... etc

        // Pre-expand profile groups
        if let Some(p) = &profile {
            *tools.expanded_groups.write().unwrap() = p.pre_expanded_groups();
        }

        tools
    }

    fn register_tool<F, Req>(&mut self, name: &str, desc: &str, group: ToolGroup, handler: F)
    where
        F: Fn(Req) -> BoxFuture<'static, Result<CallToolResult, ErrorData>> + Send + Sync + 'static,
        Req: DeserializeOwned + JsonSchema,
    {
        let schema = schemars::schema_for!(Req);
        self.tool_definitions.insert(name.to_string(), ToolDefinition {
            name: name.to_string(),
            description: desc.to_string(),
            input_schema: serde_json::to_value(schema).unwrap(),
            group,
        });

        self.tool_handlers.insert(name.to_string(), Box::new(move |params| {
            let req: Req = serde_json::from_value(params).unwrap();
            handler(req)
        }));
    }

    fn visible_tools(&self) -> Vec<&ToolDefinition> {
        let expanded = self.expanded_groups.read().unwrap();
        self.tool_definitions.values()
            .filter(|t| expanded.contains(&t.group))
            .collect()
    }

    fn expand_group(&self, group: ToolGroup) {
        self.expanded_groups.write().unwrap().insert(group);
    }
}

// Manual ServerHandler implementation
impl ServerHandler for ModernCliTools {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            instructions: Some(self.build_instructions().into()),
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            ..Default::default()
        }
    }

    async fn list_tools(&self) -> Result<Vec<Tool>, ErrorData> {
        // Only return visible tools + meta-tools
        let mut tools: Vec<Tool> = self.visible_tools()
            .iter()
            .map(|t| Tool {
                name: t.name.clone(),
                description: Some(t.description.clone()),
                input_schema: t.input_schema.clone(),
            })
            .collect();

        // Always include meta-tools
        tools.push(self.expand_tools_definition());
        tools.push(self.list_groups_definition());

        Ok(tools)
    }

    async fn call_tool(&self, name: &str, params: serde_json::Value) -> Result<CallToolResult, ErrorData> {
        // Special handling for expand_tools
        if name == "expand_tools" {
            let group: ToolGroup = serde_json::from_value(params["group"].clone())?;
            self.expand_group(group);
            return self.handle_expand_tools(group).await;
        }

        // Look up and call handler
        if let Some(handler) = self.tool_handlers.get(name) {
            handler(params).await
        } else {
            Err(ErrorData::new(
                ErrorCode::METHOD_NOT_FOUND,
                format!("Unknown tool: {}", name),
                None::<()>,
            ))
        }
    }
}
```

### Macro for Registration (Optional)

To avoid losing ergonomics, create a simpler registration macro:

```rust
macro_rules! register_tools {
    ($self:expr, $group:expr, [
        $( $name:literal => $handler:ident($req:ty) : $desc:literal ),* $(,)?
    ]) => {
        $(
            $self.register_tool::<_, $req>($name, $desc, $group, |req| {
                Box::pin(async move { Self::$handler(req).await })
            });
        )*
    };
}

impl ModernCliTools {
    fn register_filesystem_tools(&mut self) {
        register_tools!(self, ToolGroup::Filesystem, [
            "Filesystem - List (eza)" => eza(EzaRequest): "List directory contents...",
            "Filesystem - View (bat)" => bat(BatRequest): "Display file with syntax...",
            "Filesystem - Find (fd)" => fd(FdRequest): "Find files and directories...",
        ]);
    }
}
```

## Option B: Embedding-based Routing

Add semantic matching to select relevant tools before listing.

### Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Query Processing                             │
├─────────────────────────────────────────────────────────────────┤
│  1. Receive query context (via set_context tool or param)       │
│  2. Generate query embedding                                    │
│  3. Compare to pre-computed tool embeddings                     │
│  4. Select top-K tools by cosine similarity                     │
│  5. Update visible_tools set                                    │
└─────────────────────────────────────────────────────────────────┘

Pre-computed at build time:
┌─────────────────────────────────────────────────────────────────┐
│  tool_embeddings.bin                                            │
│  ├── "eza": [0.12, -0.34, 0.56, ...]  (384 dims)               │
│  ├── "bat": [0.23, -0.45, 0.67, ...]                           │
│  └── ...                                                        │
└─────────────────────────────────────────────────────────────────┘
```

### Implementation with fastembed-rs

```rust
use fastembed::{TextEmbedding, InitOptions, EmbeddingModel};

pub struct EmbeddingRouter {
    model: TextEmbedding,
    tool_embeddings: HashMap<String, Vec<f32>>,
}

impl EmbeddingRouter {
    pub fn new() -> Self {
        let model = TextEmbedding::try_new(InitOptions {
            model_name: EmbeddingModel::AllMiniLML6V2,
            show_download_progress: false,
            ..Default::default()
        }).unwrap();

        // Load pre-computed embeddings or compute on init
        let tool_embeddings = Self::load_or_compute_embeddings(&model);

        Self { model, tool_embeddings }
    }

    pub fn route(&self, query: &str, top_k: usize) -> Vec<String> {
        let query_embedding = self.model.embed(vec![query], None).unwrap()[0].clone();

        let mut scores: Vec<(String, f32)> = self.tool_embeddings
            .iter()
            .map(|(name, emb)| {
                let score = cosine_similarity(&query_embedding, emb);
                (name.clone(), score)
            })
            .collect();

        scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        scores.into_iter().take(top_k).map(|(name, _)| name).collect()
    }
}

fn cosine_similarity(a: &[f32], b: &[f32]) -> f32 {
    let dot: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
    let norm_a: f32 = a.iter().map(|x| x * x).sum::<f32>().sqrt();
    let norm_b: f32 = b.iter().map(|x| x * x).sum::<f32>().sqrt();
    dot / (norm_a * norm_b)
}
```

### MCP Integration

Since MCP doesn't pass user query to tools, we need a workaround:

```rust
#[tool(
    name = "set_task_context",
    description = "Call this first to set task context. Helps route to optimal tools."
)]
async fn set_task_context(&self, params: SetContextParams) -> Result<CallToolResult, ErrorData> {
    let relevant_tools = self.router.route(&params.task_description, 15);

    // Update visible tools
    let mut visible = self.visible_tools.write().unwrap();
    visible.clear();
    visible.extend(relevant_tools);

    // Also include always-visible meta-tools
    visible.insert("set_task_context".to_string());
    visible.insert("expand_tools".to_string());

    Ok(CallToolResult::success(vec![Content::text(
        format!("Context set. {} relevant tools activated.", visible.len())
    )]))
}
```

## Comparison

| Feature | Manual ServerHandler | Embedding Router |
|---------|---------------------|------------------|
| Implementation effort | Medium (refactor) | Medium (new component) |
| Runtime filtering | ✓ Profile-based | ✓ Query-based |
| Semantic matching | ✗ | ✓ |
| Latency impact | None | ~50-100ms per query |
| Binary size | Same | +50MB (model weights) |
| Dependencies | None new | fastembed-rs |

## Recommendation

**Phase 1:** Implement manual ServerHandler for true dynamic filtering
**Phase 2:** Add embedding router for semantic tool selection
**Phase 3:** Consider hybrid approach (profile + embeddings)

## Dependencies to Add

```toml
# For embedding-based routing
fastembed = "4"
ndarray = "0.16"

# For pre-computing embeddings at build time (optional)
[build-dependencies]
fastembed = "4"
```
